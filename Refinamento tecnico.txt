Olá! Analisando o arquivo schema.yaml, a estrutura da sua API está bem definida e oferece todos os recursos necessários para que o seu irmão consiga construir a funcionalidade que você descreveu.

Aqui está um refinamento técnico detalhado para o desenvolvedor front-end, explicando como usar cada endpoint da API para implementar a lista de compras:

Refinamento Técnico para o Front-End
1. Estrutura de Dados
A API utiliza um modelo de dados chamado Item. Cada item da lista de compras terá os seguintes campos:

id: Identificador único do item. O front-end precisará deste id para atualizar ou excluir um item específico.

nome: O nome do produto, como "Arroz", "Feijão", etc.

comprado: Um valor booleano (true ou false) que indica se o item já foi comprado ou não.

2. Implementação das Funcionalidades
A. Adicionar um Item à Lista

Método: POST

Endpoint: /api/itens/

Corpo da Requisição (JSON): O front-end deve enviar um objeto JSON contendo apenas o nome do item. O campo comprado pode ser omitido, pois a API provavelmente o definirá como false por padrão.

JSON

{
  "nome": "Nome do item"
}
B. Exibir as Listas de Itens (a Comprar e Comprados)

Método: GET

Endpoint: /api/itens/

Retorno: A API retornará uma lista de todos os itens cadastrados. O front-end deve fazer uma única requisição a este endpoint e, em seguida, usar a lógica de front-end para separar os itens em duas listas com base no valor do campo comprado:

Lista de Compras (a Comprar): Mostrar os itens onde comprado é false.

Lista de Itens Comprados: Mostrar os itens onde comprado é true.

C. Marcar um Item como Comprado

Para mover um item da lista "a Comprar" para a lista "Comprados", o front-end precisa atualizar o estado do item na API.

Método: PATCH

Endpoint: /api/itens/{id}/. O {id} deve ser substituído pelo id do item que está sendo marcado como comprado.

Corpo da Requisição (JSON):

JSON

{
  "comprado": true
}
D. Desmarcar um Item (e movê-lo de volta)

Para mover um item da lista "Comprados" para a lista "a Comprar", o processo é o mesmo que o anterior, mas o valor do campo comprado deve ser alterado para false.

Método: PATCH

Endpoint: /api/itens/{id}/

Corpo da Requisição (JSON):

JSON

{
  "comprado": false
}
A sua API está bem projetada para atender a essas necessidades. Basta que o front-end implemente essa lógica de requisição e atualização do estado local para que a aplicação funcione como você deseja.


CóDIGO



<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lista de Compras</title>
    <!-- Adiciona a biblioteca Tailwind CSS para estilização rápida -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Fundo preto/escuro */
        }
        .container {
            max-width: 1024px;
        }
        .item-list-container {
            min-height: 200px;
        }
        .loading-overlay {
            background-color: rgba(26, 32, 44, 0.8); /* Fundo escuro semi-transparente */
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="container mx-auto bg-gray-800 rounded-3xl shadow-xl p-6 md:p-10">
        
        <h1 class="text-4xl md:text-5xl font-bold text-center mb-8 text-orange-400">
            Minha Lista de Compras
        </h1>
        
        <!-- Navegação entre as rotas -->
        <nav class="mb-8 flex justify-center gap-4 border-b-2 border-gray-700">
            <a href="#home" id="home-link" class="py-3 px-6 text-xl font-semibold text-gray-400 hover:text-orange-400 transition-colors duration-200 ease-in-out border-b-4 border-transparent hover:border-orange-500">
                A Comprar
            </a>
            <a href="#comprados" id="comprados-link" class="py-3 px-6 text-xl font-semibold text-gray-400 hover:text-orange-400 transition-colors duration-200 ease-in-out border-b-4 border-transparent hover:border-orange-500">
                Comprados
            </a>
        </nav>

        <!-- Conteúdo da Rota Home -->
        <div id="homePage">
            <!-- Formulário para adicionar novos itens -->
            <div class="mb-8 flex flex-col md:flex-row items-center gap-4">
                <input 
                    type="text" 
                    id="newItemInput" 
                    placeholder="Adicionar novo item..."
                    class="w-full md:flex-1 p-4 text-lg border-2 bg-gray-700 border-orange-400 text-white rounded-2xl focus:outline-none focus:border-orange-600 transition-colors"
                >
                <button 
                    id="addItemButton"
                    class="w-full md:w-auto p-4 bg-orange-600 hover:bg-orange-700 text-white font-semibold rounded-2xl transition-transform transform hover:scale-105 shadow-md"
                >
                    Adicionar Item
                </button>
            </div>
            
            <!-- Lista de itens a comprar -->
            <div class="bg-gray-900 p-6 rounded-2xl shadow-inner relative item-list-container">
                <h2 class="text-2xl font-bold text-orange-400 mb-4 text-center">Itens a Comprar</h2>
                <div id="unpurchasedItemsList" class="space-y-4">
                    <!-- Itens a comprar serão renderizados aqui pelo JavaScript -->
                </div>
                <div id="unpurchasedLoading" class="loading-overlay absolute inset-0 flex items-center justify-center hidden rounded-2xl">
                    <i class="fa-solid fa-spinner fa-spin text-4xl text-orange-500"></i>
                </div>
            </div>
        </div>

        <!-- Conteúdo da Rota Comprados -->
        <div id="purchasedPage" class="hidden">
            <!-- Lista de itens comprados -->
            <div class="bg-gray-900 p-6 rounded-2xl shadow-inner relative item-list-container">
                <h2 class="text-2xl font-bold text-orange-400 mb-4 text-center">Itens Comprados</h2>
                <div id="purchasedItemsList" class="space-y-4">
                    <!-- Itens comprados serão renderizados aqui pelo JavaScript -->
                </div>
                <div id="purchasedLoading" class="loading-overlay absolute inset-0 flex items-center justify-center hidden rounded-2xl">
                    <i class="fa-solid fa-spinner fa-spin text-4xl text-orange-500"></i>
                </div>
            </div>
        </div>

        <!-- Modal de Mensagem -->
        <div id="messageModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
            <div class="bg-gray-800 rounded-xl shadow-lg p-6 w-full max-w-sm text-center">
                <p id="messageText" class="text-white font-semibold mb-4"></p>
                <button id="closeModalButton" class="w-full py-3 bg-orange-600 text-white rounded-xl font-bold hover:bg-orange-700 transition-colors">OK</button>
            </div>
        </div>

    </div>

    <script>
        // Simulação de uma API para fins de demonstração.
        // Na aplicação real, você substituiria estas funções por chamadas 'fetch' para os endpoints da sua API.

        const api = {
            _items: [],
            
            // Simula a busca de todos os itens da API
            getItems: function() {
                return new Promise(resolve => {
                    setTimeout(() => {
                        resolve(this._items);
                    }, 500); // Simula latência de rede
                });
            },

            // Simula a criação de um novo item
            createItem: function(newItem) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        const item = {
                            id: Date.now(), // ID simples para a simulação
                            nome: newItem.nome,
                            comprado: false
                        };
                        this._items.push(item);
                        resolve(item);
                    }, 500);
                });
            },

            // Simula a atualização de um item
            updateItem: function(id, data) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        const itemIndex = this._items.findIndex(item => item.id === id);
                        if (itemIndex !== -1) {
                            this._items[itemIndex] = { ...this._items[itemIndex], ...data };
                            resolve(this._items[itemIndex]);
                        } else {
                            resolve(null);
                        }
                    }, 500);
                });
            }
        };

        // Estado da aplicação
        let shoppingItems = [];

        // Elementos do DOM
        const homePage = document.getElementById('homePage');
        const purchasedPage = document.getElementById('purchasedPage');
        const homeLink = document.getElementById('home-link');
        const compradosLink = document.getElementById('comprados-link');
        const unpurchasedList = document.getElementById('unpurchasedItemsList');
        const purchasedList = document.getElementById('purchasedItemsList');
        const newItemInput = document.getElementById('newItemInput');
        const addItemButton = document.getElementById('addItemButton');
        const unpurchasedLoading = document.getElementById('unpurchasedLoading');
        const purchasedLoading = document.getElementById('purchasedLoading');
        const messageModal = document.getElementById('messageModal');
        const messageText = document.getElementById('messageText');
        const closeModalButton = document.getElementById('closeModalButton');

        // Função para mostrar mensagens ao usuário
        function showMessage(text) {
            messageText.textContent = text;
            messageModal.classList.remove('hidden');
        }

        // Função para esconder o modal de mensagem
        closeModalButton.addEventListener('click', () => {
            messageModal.classList.add('hidden');
        });

        // Função para renderizar um item na tela
        function renderItem(item, parentList) {
            const itemElement = document.createElement('div');
            // A classe para o item comprado foi ajustada para o tema escuro
            itemElement.className = `flex items-center justify-between p-4 rounded-xl shadow-sm transition-colors cursor-pointer ${item.comprado ? 'bg-gray-700 text-gray-500 line-through' : 'bg-gray-700 text-white hover:bg-gray-600'}`;
            itemElement.dataset.id = item.id;

            const itemName = document.createElement('span');
            itemName.textContent = item.nome;
            itemName.className = 'flex-1';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = item.comprado;
            // Estilo do checkbox também foi ajustado
            checkbox.className = 'w-5 h-5 text-orange-400 bg-gray-600 border-gray-500 rounded focus:ring-orange-500';
            
            checkbox.addEventListener('change', () => togglePurchased(item.id, !item.comprado));

            itemElement.appendChild(itemName);
            itemElement.appendChild(checkbox);
            parentList.appendChild(itemElement);
        }

        // Função para renderizar as listas de acordo com a rota
        function renderLists() {
            unpurchasedList.innerHTML = '';
            purchasedList.innerHTML = '';
            
            const unpurchasedItems = shoppingItems.filter(item => !item.comprado);
            const purchasedItems = shoppingItems.filter(item => item.comprado);

            // Renderiza apenas a lista da página ativa
            const currentHash = window.location.hash || '#home';
            if (currentHash === '#home') {
                unpurchasedItems.forEach(item => renderItem(item, unpurchasedList));
                if (unpurchasedItems.length === 0) {
                    unpurchasedList.innerHTML = '<p class="text-center text-gray-400">Nenhum item para comprar. 🎉</p>';
                }
            } else if (currentHash === '#comprados') {
                purchasedItems.forEach(item => renderItem(item, purchasedList));
                if (purchasedItems.length === 0) {
                    purchasedList.innerHTML = '<p class="text-center text-gray-400">Nenhum item comprado.</p>';
                }
            }
        }

        // Função para carregar os itens da API
        async function loadItems() {
            unpurchasedLoading.classList.remove('hidden');
            purchasedLoading.classList.remove('hidden');
            try {
                shoppingItems = await api.getItems();
                renderLists();
            } catch (error) {
                showMessage('Erro ao carregar a lista de compras.');
                console.error(error);
            } finally {
                unpurchasedLoading.classList.add('hidden');
                purchasedLoading.classList.add('hidden');
            }
        }

        // Função para adicionar um novo item
        async function addItem() {
            const itemName = newItemInput.value.trim();
            if (itemName === '') {
                showMessage('Por favor, digite um nome para o item.');
                return;
            }

            addItemButton.disabled = true;
            addItemButton.textContent = 'Adicionando...';
            unpurchasedLoading.classList.remove('hidden');

            try {
                const newItem = await api.createItem({ nome: itemName });
                shoppingItems.push(newItem);
                renderLists();
                newItemInput.value = '';
            } catch (error) {
                showMessage('Erro ao adicionar o item.');
                console.error(error);
            } finally {
                addItemButton.disabled = false;
                addItemButton.textContent = 'Adicionar Item';
                unpurchasedLoading.classList.add('hidden');
            }
        }

        // Função para marcar/desmarcar um item como comprado
        async function togglePurchased(itemId, isPurchased) {
            unpurchasedLoading.classList.remove('hidden');
            purchasedLoading.classList.remove('hidden');
            try {
                const updatedItem = await api.updateItem(itemId, { comprado: isPurchased });
                if (updatedItem) {
                    const index = shoppingItems.findIndex(item => item.id === itemId);
                    shoppingItems[index] = updatedItem;
                    renderLists();
                }
            } catch (error) {
                showMessage('Erro ao atualizar o item.');
                console.error(error);
            } finally {
                unpurchasedLoading.classList.add('hidden');
                purchasedLoading.classList.add('hidden');
            }
        }

        // Função para renderizar a página correta e atualizar o estado da navegação
        function renderPage() {
            const hash = window.location.hash || '#home';
            
            // Esconde todas as páginas e remove o estilo de link ativo
            homePage.classList.add('hidden');
            purchasedPage.classList.add('hidden');
            homeLink.classList.remove('border-orange-500');
            compradosLink.classList.remove('border-orange-500');
            homeLink.classList.add('border-transparent');
            compradosLink.classList.add('border-transparent');

            // Mostra a página correta e adiciona o estilo de link ativo
            if (hash === '#comprados') {
                purchasedPage.classList.remove('hidden');
                compradosLink.classList.add('border-orange-500');
                compradosLink.classList.remove('border-transparent');
            } else {
                homePage.classList.remove('hidden');
                homeLink.classList.add('border-orange-500');
                homeLink.classList.remove('border-transparent');
            }
            
            // Renderiza as listas novamente para refletir a mudança de página
            renderLists();
        }
        
        // Event listeners
        addItemButton.addEventListener('click', addItem);
        newItemInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addItem();
            }
        });

        // Adiciona um listener para a mudança de hash da URL
        window.addEventListener('hashchange', renderPage);

        // Carrega os itens e renderiza a página correta na primeira carga
        document.addEventListener('DOMContentLoaded', () => {
            loadItems();
            renderPage();
        });
    </script>
</body>
</html>

